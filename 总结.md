#OC总结




1、禁止手机睡眠

	[UIApplication sharedApplication].idleTimerDisabled = YES;




2、隐藏某行cell

	- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
    // 如果是你需要隐藏的那一行，返回高度为0
    if(indexPath.row == YouWantToHideRow)
                return 0;
        return 44;
    }

    // 然后再你需要隐藏cell的时候调用
    [self.tableView beginUpdates];
    [self.tableView endUpdates];
    
3、禁用button高亮

    button.adjustsImageWhenHighlighted = NO;
    或者在创建的时候
    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];
    
    
    
4、动画切换window的根控制器
   
    // options是动画选项
    [UIView transitionWithView:[UIApplication sharedApplication].keyWindow duration:0.5f options:UIViewAnimationOptionTransitionCrossDissolve animations:^{
                BOOL oldState = [UIView areAnimationsEnabled];
                [UIView setAnimationsEnabled:NO];
                [UIApplication sharedApplication].keyWindow.rootViewController = [RootViewController new];
                [UIView setAnimationsEnabled:oldState];
    } completion:^(BOOL finished) {
    
    }];
    
5、去除数组中重复的对象

    NSArray *newArr = [oldArr valueForKeyPath:@“@distinctUnionOfObjects.self"];
    
6、设置navigationBar上的title颜色和大小

    [self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName : [UIColor youColor], NSFontAttributeName : [UIFont systemFontOfSize:15]}]
    
7、颜色转图片

    + (UIImage *)cl_imageWithColor:(UIColor *)color {
    
        CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
        UIGraphicsBeginImageContext(rect.size);
        CGContextRef context = UIGraphicsGetCurrentContext();
        
        CGContextSetFillColorWithColor(context, [color CGColor]);
        CGContextFillRect(context, rect);
        
        UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        
        return image;
    }
    
8、强／弱引用

    #define WeakSelf(type)  __weak typeof(type) weak##type = type; // weak
    #define StrongSelf(type)  __strong typeof(type) type = weak##type; // strong
    
9、由角度转换弧度

    #define DegreesToRadian(x) (M_PI * (x) / 180.0)
    
10、由弧度转换角度

    #define RadianToDegrees(radian) (radian*180.0)/(M_PI)
    
11、自定义NSLog
    
    #ifdef DEBUG
    #define NSLog(fmt, ...) NSLog((@"%s [Line %d] " fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)
    #else
    #define NSLog(...)
    #endif
    
12、随机颜色

    + (UIColor *)RandomColor {
    
        NSInteger aRedValue = arc4random() % 255;
        NSInteger aGreenValue = arc4random() % 255;
        NSInteger aBlueValue = arc4random() % 255;
        UIColor *randColor = [UIColor colorWithRed:aRedValue / 255.0f green:aGreenValue / 255.0f blue:aBlueValue / 255.0f alpha:1.0f];
        return randColor;
    }
    
13、获取window
    
    +(UIWindow*)getWindow {
    
        UIWindow* win = nil;
        //[UIApplicationsharedApplication].keyWindow;
        for (id item in [UIApplication sharedApplication].windows) {
            if ([item class] == [UIWindow class]) {
                if (!((UIWindow*)item).hidden) {
                    win = item;
                    break;
                }
            }
        }
        return win;
    }
    
14、控制屏幕旋转，在控制器中写

    /** 是否支持自动转屏 */
    - (BOOL)shouldAutorotate {
    
            return YES;
    }
    
    /** 支持哪些屏幕方向 */
    - (UIInterfaceOrientationMask)supportedInterfaceOrientations {
    
        return UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight;
    }
    
    /** 默认的屏幕方向（当前ViewController必须是通过模态出来的UIViewController（模态带导航的无效）方式展现出来的，才会调用这个方法） */
    - (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {
    
        return UIInterfaceOrientationLandscapeLeft | UIInterfaceOrientationLandscapeRight;
    }
    
15、获取app缓存大小

    - (CGFloat)getCachSize {
    
        NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize];
        //获取自定义缓存大小
        //用枚举器遍历 一个文件夹的内容
        //1.获取 文件夹枚举器
        NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@"Library/Caches"];
        NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath];
        __block NSUInteger count = 0;
        //2.遍历
        for (NSString *fileName in enumerator) {
        NSString *path = [myCachePath stringByAppendingPathComponent:fileName];
        NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil];
        count += fileDict.fileSize;//自定义所有缓存大小
        }
        // 得到是字节  转化为M
        CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024;
        return totalSize;
    }
    
16、清理app缓存
    - (void)handleClearView {
    
        //删除两部分
        //1.删除 sd 图片缓存
        //先清除内存中的图片缓存
        [[SDImageCache sharedImageCache] clearMemory];
        //清除磁盘的缓存
        [[SDImageCache sharedImageCache] clearDisk];
        //2.删除自己缓存
        NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@"Library/Caches"];
        [[NSFileManager defaultManager] removeItemAtPath:myCachePath error:nil];
    }
    
17、模型转字典

    static NSSet *classes;
    - (NSMutableDictionary *)getParameterDictionary {
    
        NSMutableDictionary *dict = [NSMutableDictionary dictionary];
        
        Class c = self.class;
        
        while (c) {
        unsigned count;
        objc_property_t *properties = class_copyPropertyList([c class], &count);
        
        for (int i = 0; i < count; i++) {
        NSString *key = [NSString stringWithUTF8String:property_getName(properties[i])];
        dict[key] = [self valueForKey:key];
        }
        free(properties);
        
        // 获得父类
        c = class_getSuperclass(c);
        
        if ([self isClassFromFoundation:c]) break;
        }
        return dict;
    }
    
    - (BOOL)isClassFromFoundation:(Class)c
    {
        if (c == [NSObject class] || c == [NSManagedObject class]) return YES;
        
        __block BOOL result = NO;
        [[self foundationClasses] enumerateObjectsUsingBlock:^(Class foundationClass, BOOL *stop) {
            if ([c isSubclassOfClass:foundationClass]) {
                result = YES;
                *stop = YES;
            }
        }];
        return result;
    }
    
    - (NSSet *)foundationClasses
    {
    
        if (classes == nil) {
        // 集合中没有NSObject，因为几乎所有的类都是继承自NSObject，具体是不是NSObject需要特殊判断
        classes = [NSSet setWithObjects:
        [NSURL class],
        [NSDate class],
        [NSValue class],
        [NSData class],
        [NSError class],
        [NSArray class],
        [NSDictionary class],
        [NSString class],
        [NSAttributedString class], nil];
        }
        return classes;
    }
    
18、几个常用权限判断


    if ([CLLocationManager authorizationStatus] ==kCLAuthorizationStatusDenied) {
    
        NSLog(@"没有定位权限");
    }
    AVAuthorizationStatus statusVideo = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];
    if (statusVideo == AVAuthorizationStatusDenied) {
    
        NSLog(@"没有摄像头权限");
    }
    //是否有麦克风权限
    AVAuthorizationStatus statusAudio = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio];
    if (statusAudio == AVAuthorizationStatusDenied) {
    
        NSLog(@"没有录音权限");
    }
    [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) {
    
        if (status == PHAuthorizationStatusDenied) {
        
            NSLog(@"没有相册权限");
        }
    }];
    
    
19、获取手机型号

    + (NSString *)getDeviceInfo {
    
        struct utsname systemInfo;
        uname(&systemInfo);
        NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];
        if ([platform isEqualToString:@"iPhone1,1"]) return @"iPhone 2G";
        if ([platform isEqualToString:@"iPhone1,2"]) return @"iPhone 3G";
        if ([platform isEqualToString:@"iPhone2,1"]) return @"iPhone 3GS";
        if ([platform isEqualToString:@"iPhone3,1"]) return @"iPhone 4";
        if ([platform isEqualToString:@"iPhone3,2"]) return @"iPhone 4";
        if ([platform isEqualToString:@"iPhone3,3"]) return @"iPhone 4";
        if ([platform isEqualToString:@"iPhone4,1"]) return @"iPhone 4S";
        if ([platform isEqualToString:@"iPhone5,1"]) return @"iPhone 5";
        if ([platform isEqualToString:@"iPhone5,2"]) return @"iPhone 5";
        if ([platform isEqualToString:@"iPhone5,3"]) return @"iPhone 5c";
        if ([platform isEqualToString:@"iPhone5,4"]) return @"iPhone 5c";
        if ([platform isEqualToString:@"iPhone6,1"]) return @"iPhone 5s";
        if ([platform isEqualToString:@"iPhone6,2"]) return @"iPhone 5s";
        if ([platform isEqualToString:@"iPhone7,1"]) return @"iPhone 6 Plus";
        if ([platform isEqualToString:@"iPhone7,2"]) return @"iPhone 6";
        if ([platform isEqualToString:@"iPhone8,1"]) return @"iPhone 6s";
        if ([platform isEqualToString:@"iPhone8,2"]) return @"iPhone 6s Plus";
        // 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付
        if ([platform isEqualToString:@"iPhone9,1"])    return @"国行、日版、港行iPhone 7";
        if ([platform isEqualToString:@"iPhone9,2"])    return @"港行、国行iPhone 7 Plus";
        if ([platform isEqualToString:@"iPhone9,3"])    return @"美版、台版iPhone 7";
        if ([platform isEqualToString:@"iPhone9,4"])    return @"美版、台版iPhone 7 Plus";
        if ([platform isEqualToString:@"iPhone8,4"]) return @"iPhone SE";
        if ([platform isEqualToString:@"iPod1,1"]) return @"iPod Touch 1G";
        if ([platform isEqualToString:@"iPod2,1"]) return @"iPod Touch 2G";
        if ([platform isEqualToString:@"iPod3,1"]) return @"iPod Touch 3G";
        if ([platform isEqualToString:@"iPod4,1"]) return @"iPod Touch 4G";
        if ([platform isEqualToString:@"iPod5,1"]) return @"iPod Touch 5G";
        if ([platform isEqualToString:@"iPad1,1"]) return @"iPad 1G";
        if ([platform isEqualToString:@"iPad2,1"]) return @"iPad 2";
        if ([platform isEqualToString:@"iPad2,2"]) return @"iPad 2";
        if ([platform isEqualToString:@"iPad2,3"]) return @"iPad 2";
        if ([platform isEqualToString:@"iPad2,4"]) return @"iPad 2";
        if ([platform isEqualToString:@"iPad2,5"]) return @"iPad Mini 1G";
        if ([platform isEqualToString:@"iPad2,6"]) return @"iPad Mini 1G";
        if ([platform isEqualToString:@"iPad2,7"]) return @"iPad Mini 1G";
        if ([platform isEqualToString:@"iPad3,1"]) return @"iPad 3";
        if ([platform isEqualToString:@"iPad3,2"]) return @"iPad 3";
        if ([platform isEqualToString:@"iPad3,3"]) return @"iPad 3";
        if ([platform isEqualToString:@"iPad3,4"]) return @"iPad 4";
        if ([platform isEqualToString:@"iPad3,5"]) return @"iPad 4";
        if ([platform isEqualToString:@"iPad3,6"]) return @"iPad 4";
        if ([platform isEqualToString:@"iPad4,1"]) return @"iPad Air";
        if ([platform isEqualToString:@"iPad4,2"]) return @"iPad Air";
        if ([platform isEqualToString:@"iPad4,3"]) return @"iPad Air";
        if ([platform isEqualToString:@"iPad4,4"]) return @"iPad Mini 2G";
        if ([platform isEqualToString:@"iPad4,5"]) return @"iPad Mini 2G";
        if ([platform isEqualToString:@"iPad4,6"]) return @"iPad Mini 2G";
        if ([platform isEqualToString:@"i386"]) return @"iPhone Simulator";
        if ([platform isEqualToString:@"x86_64"]) return @"iPhone Simulator";
        return platform;
    }
    
20、判断图片类型

    //通过图片Data数据第一个字节 来获取图片扩展名
    - (NSString *)contentTypeForImageData:(NSData *)data {
    
            uint8_t c;
            [data getBytes:&c length:1];
            switch (c)
            {
                case 0xFF:
                return @"jpeg";
                
                case 0x89:
                return @"png";
                
                case 0x47:
                return @"gif";
                
                case 0x49:
                case 0x4D:
                return @"tiff";
                
                case 0x52:
                if ([data length] < 12) {
                    return nil;
                }
            
                NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];
                if ([testString hasPrefix:@"RIFF"] && [testString hasSuffix:@"WEBP"]) {
                    return @"webp";
                }
            
                return nil;
            }
            
            return nil;
        }
    
21、获取手机和app信息
    
        NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];
        CFShow(infoDictionary);
        // app名称
        NSString *app_Name = [infoDictionary objectForKey:@"CFBundleDisplayName"];
        // app版本
        NSString *app_Version = [infoDictionary objectForKey:@"CFBundleShortVersionString"];
        // app build版本
        NSString *app_build = [infoDictionary objectForKey:@"CFBundleVersion"];
        
        //手机序列号
        NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier];
        NSLog(@"手机序列号: %@",identifierNumber);
        //手机别名： 用户定义的名称
        NSString* userPhoneName = [[UIDevice currentDevice] name];
        NSLog(@"手机别名: %@", userPhoneName);
        //设备名称
        NSString* deviceName = [[UIDevice currentDevice] systemName];
        NSLog(@"设备名称: %@",deviceName );
        //手机系统版本
        NSString* phoneVersion = [[UIDevice currentDevice] systemVersion];
        NSLog(@"手机系统版本: %@", phoneVersion);
        //手机型号
        NSString* phoneModel = [[UIDevice currentDevice] model];
        NSLog(@"手机型号: %@",phoneModel );
        //地方型号  （国际化区域名称）
        NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel];
        NSLog(@"国际化区域名称: %@",localPhoneModel );
        
        NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];
        
        NSString *appCurName = [infoDictionary objectForKey:@"CFBundleDisplayName"];
        NSLog(@"当前应用名称：%@",appCurName);
        
        NSString *appCurVersion = [infoDictionary objectForKey:@"CFBundleShortVersionString"];
        NSLog(@"当前应用软件版本:%@",appCurVersion);
        // 应用版本号码   int类型
        NSString *appCurVersionNum = [infoDictionary objectForKey:@"CFBundleVersion"];
        NSLog(@"当前应用版本号码：%@",appCurVersionNum);
    
    
22、JSON字符串转字典
    
        + (NSDictionary *)parseJSONStringToNSDictionary:(NSString *)JSONString {
            NSData *JSONData = [JSONString dataUsingEncoding:NSUTF8StringEncoding];
            NSDictionary *responseJSON = [NSJSONSerialization JSONObjectWithData:JSONData options:NSJSONReadingMutableLeaves error:nil];
            return responseJSON;
        }
    
23、获取设备mac地址

	+ (NSString *)macAddress {
            int                 mib[6];
            size_t              len;
            char                *buf;
            unsigned char       *ptr;
            struct if_msghdr    *ifm;
            struct sockaddr_dl  *sdl;
            
            mib[0] = CTL_NET;
            mib[1] = AF_ROUTE;
            mib[2] = 0;
            mib[3] = AF_LINK;
            mib[4] = NET_RT_IFLIST;
            
            if((mib[5] = if_nametoindex("en0")) == 0) {
                printf("Error: if_nametoindex error\n");
                return NULL;
            }
            
            if(sysctl(mib, 6, NULL, &len, NULL, 0) < 0) {
                printf("Error: sysctl, take 1\n");
                return NULL;
            }
            
            if((buf = malloc(len)) == NULL) {
                printf("Could not allocate memory. Rrror!\n");
                return NULL;
            }
            
            if(sysctl(mib, 6, buf, &len, NULL, 0) < 0) {
                printf("Error: sysctl, take 2");
                return NULL;
            }
            
            ifm = (struct if_msghdr *)buf;
            sdl = (struct sockaddr_dl *)(ifm + 1);
            ptr = (unsigned char *)LLADDR(sdl);
            NSString *outstring = [NSString stringWithFormat:@"%02X:%02X:%02X:%02X:%02X:%02X",
            *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];
            free(buf);
            
            return outstring;
        }
    
24、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到
    
        + (UIViewController *)getVisibleViewControllerFrom:(UIViewController*)vc {

            if ([vc isKindOfClass:[UINavigationController class]]) {
                return [self getVisibleViewControllerFrom:[((UINavigationController*) vc) visibleViewController]];
            }else if ([vc isKindOfClass:[UITabBarController class]]){
                return [self getVisibleViewControllerFrom:[((UITabBarController*) vc) selectedViewController]];
            } else if(vc.presentedViewController) {

                return [self getVisibleViewControllerFrom:vc.presentedViewController];
            } else {

                return vc;
            }
        }
    
25、取图片某一点的颜色

    - (UIColor *)colorAtPixel:(CGPoint)point {
    
            if (point.x < 0 || point.y < 0) return nil;
            
            CGImageRef imageRef = self.CGImage;
            NSUInteger width = CGImageGetWidth(imageRef);
            NSUInteger height = CGImageGetHeight(imageRef);
            if (point.x >= width || point.y >= height) return nil;
            
            unsigned char *rawData = malloc(height * width * 4);
            if (!rawData) return nil;
            
            CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
            NSUInteger bytesPerPixel = 4;
            NSUInteger bytesPerRow = bytesPerPixel * width;
            NSUInteger bitsPerComponent = 8;
            CGContextRef context = CGBitmapContextCreate(rawData,
            width,
            height,
            bitsPerComponent,
            bytesPerRow,
            colorSpace,
            kCGImageAlphaPremultipliedLast
            | kCGBitmapByteOrder32Big);
            if (!context) {
            free(rawData);
            return nil;
            }
            CGColorSpaceRelease(colorSpace);
            CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);
            CGContextRelease(context);
            
            int byteIndex = (bytesPerRow * point.y) + point.x * bytesPerPixel;
            CGFloat red   = (rawData[byteIndex]     * 1.0) / 255.0;
            CGFloat green = (rawData[byteIndex + 1] * 1.0) / 255.0;
            CGFloat blue  = (rawData[byteIndex + 2] * 1.0) / 255.0;
            CGFloat alpha = (rawData[byteIndex + 3] * 1.0) / 255.0;
            
            UIColor *result = nil;
            result = [UIColor colorWithRed:red green:green blue:blue alpha:alpha];
            free(rawData);
            return result;
            }
        
26、判断该图片是否有透明度通道
    
        - (BOOL)hasAlphaChannel {
            CGImageAlphaInfo alpha = CGImageGetAlphaInfo(self.CGImage);
            return (alpha == kCGImageAlphaFirst ||
            alpha == kCGImageAlphaLast ||
            alpha == kCGImageAlphaPremultipliedFirst ||
            alpha == kCGImageAlphaPremultipliedLast);
        }
    
27、获得灰度图
    
        + (UIImage*)covertToGrayImageFromImage:(UIImage*)sourceImage{
            int width = sourceImage.size.width;
            int height = sourceImage.size.height;
            
            CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();
            CGContextRef context = CGBitmapContextCreate (nil,width,height,8,0,colorSpace,kCGImageAlphaNone);
            CGColorSpaceRelease(colorSpace);
            
            if (context == NULL) {
            return nil;
            }
            
            CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage);
            CGImageRef contextRef = CGBitmapContextCreateImage(context);
            UIImage *grayImage = [UIImage imageWithCGImage:contextRef];
            CGContextRelease(context);
            CGImageRelease(contextRef);
            
            return grayImage;
        }
    
28、一个字符串是否包含另一个字符串
    
        // 方法1  //ios8以后使用
        if ([str1 containsString:str2]) {
        NSLog(@"str1包含str2");
        } else {
        NSLog(@"str1不包含str2");
        }
        
        // 方法2 //ios7一样可以使用
        if ([str1 rangeOfString: str2].location == NSNotFound) {
        NSLog(@"str1包含str2");
        } else {
        NSLog(@"str1不包含str2");
        }
    
29、移除字符串中的空格和换行
    
        + (NSString *)removeSpaceAndNewline:(NSString *)str {
            NSString *temp = [str stringByReplacingOccurrencesOfString:@" " withString:@""];
            temp = [temp stringByReplacingOccurrencesOfString:@"\r" withString:@""];
            temp = [temp stringByReplacingOccurrencesOfString:@"\n" withString:@""];
            return temp;
        }
        
        
30、字符串是否为空
        
        + (BOOL)isEqualToNil:(NSString *)str {
        return str.length <= 0 || [str isEqualToString:@""] || !str;
        }
    
31、约束如何做UIView动画？
    
    1、把需要改的约束Constraint拖条线出来，成为属性
    2、在需要动画的地方加入代码，改变此属性的constant属性
    3、开始做UIView动画，动画里边调用layoutIfNeeded方法
    
        @property (weak, nonatomic) IBOutlet NSLayoutConstraint *buttonTopConstraint;
        self.buttonTopConstraint.constant = 100;
        [UIView animateWithDuration:.5 animations:^{
        [self.view layoutIfNeeded];
        }];
        
32、从NSURL中拿到链接字符串
        
        NSString *urlString = myURL.absoluteString;
        
        
33、删除NSUserDefaults所有记录
        
    //方法一
    NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];
    [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];
    //方法二
    - (void)resetDefaults {
    NSUserDefaults * defs = [NSUserDefaults standardUserDefaults];
    NSDictionary * dict = [defs dictionaryRepresentation];
    for (id key in dict) {
    [defs removeObjectForKey:key];
    }
    [defs synchronize];
    }
    // 方法三
    [[NSUserDefaults standardUserDefaults] setPersistentDomain:[NSDictionary dictionary] forName:[[NSBundle mainBundle] bundleIdentifier]];
        
34、禁用系统滑动返回功能
        
    - (void)viewDidAppear:(BOOL)animated {
        [super viewDidAppear:animated];
        if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {
            self.navigationController.interactivePopGestureRecognizer.delegate = self;
        }
    }
    
    - (void)viewWillDisappear:(BOOL)animated {
        [super viewWillDisappear:animated];
        if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {
            self.navigationController.interactivePopGestureRecognizer.delegate = nil;
        }
    }
    - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer {
        return NO;
    }
        
35、自定义cell选中背景颜色
        
	UIView *bgColorView = [[UIView alloc] init];
	bgColorView.backgroundColor = [UIColor redColor];
	[cell setSelectedBackgroundView:bgColorView];
        
36、为UIView某个角添加圆角
        
    // 左上角和右下角添加圆角
    UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:view.bounds byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerBottomRight) cornerRadii:CGSizeMake(20, 20)];
    CAShapeLayer *maskLayer = [CAShapeLayer layer];
    maskLayer.frame = view.bounds;
    maskLayer.path = maskPath.CGPath;
    view.layer.mask = maskLayer;
        
37、将一个view放置在其兄弟视图的最上面
        
    [parentView bringSubviewToFront:yourView];
    
38、将一个view放置在其兄弟视图的最下面
        
    [parentView sendSubviewToBack:yourView];
    
39、让手机震动一下
    
    导入框架
    #import <AudioToolbox/AudioToolbox.h>
    AudioServicesPlayAlertSound(kSystemSoundID_Vibrate);
    或者
    AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);
        
40、获取view的坐标在整个window上的位置
        
    // v上的(0, 0)点在toView上的位置
    CGPoint point = [v convertPoint:CGPointMake(0, 0) toView:[UIApplication sharedApplication].windows.lastObject];
    或者
    CGPoint point = [v.superview convertPoint:v.frame.origin toView:[UIApplication sharedApplication].windows.lastObject];
        
41、在非ViewController的地方弹出UIAlertController对话框
        
    //  最好抽成一个分类
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"Title" message:@"message" preferredStyle:UIAlertControllerStyleAlert];
    //...
    id rootViewController = [UIApplication sharedApplication].delegate.window.rootViewController;
    if([rootViewController isKindOfClass:[UINavigationController class]])
    {
    rootViewController = ((UINavigationController *)rootViewController).viewControllers.firstObject;
    }
    if([rootViewController isKindOfClass:[UITabBarController class]])
    {
    rootViewController = ((UITabBarController *)rootViewController).selectedViewController;
    }
    [rootViewController presentViewController:alertController animated:YES completion:nil];
        
42、获取一个view所属的控制器
        
    // view分类方法
    - (UIViewController *)belongViewController {
        for (UIView *next = [self superview]; next; next = next.superview) {
            UIResponder* nextResponder = [next nextResponder];
            if ([nextResponder isKindOfClass:[UIViewController class]]) {
                return (UIViewController *)nextResponder;
            }
        }
        return nil;
    }
    //或者
    - (UIViewController *)viewController
    {
        UIViewController *viewController = nil;
        UIResponder *next = self.nextResponder;
        while (next)
        {
            if ([next isKindOfClass:[UIViewController class]])
            {
                viewController = (UIViewController *)next;
                break;
            }
            next = next.nextResponder;
        }
        return viewController;
    }
        
43、UIImage和base64互转
        
    // view分类方法
    - (NSString *)encodeToBase64String:(UIImage *)image {
    return [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];
    }
    
    - (UIImage *)decodeBase64ToImage:(NSString *)strEncodeData {
    NSData *data = [[NSData alloc]initWithBase64EncodedString:strEncodeData options:NSDataBase64DecodingIgnoreUnknownCharacters];
    return [UIImage imageWithData:data];
    }
        
44、判断NSDate是不是今天
        
    NSDateComponents *otherDay = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:aDate];
    NSDateComponents *today = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:[NSDate date]];
    if([today day] == [otherDay day] &&
    [today month] == [otherDay month] &&
    [today year] == [otherDay year] &&
    [today era] == [otherDay era]) {
    // 是今天
    }
        
45、比较两个颜色是否相等
        
    - (BOOL)isEqualToColor:(UIColor *)otherColor {
    CGColorSpaceRef colorSpaceRGB = CGColorSpaceCreateDeviceRGB();
    
    UIColor *(^convertColorToRGBSpace)(UIColor*) = ^(UIColor *color) {
    if (CGColorSpaceGetModel(CGColorGetColorSpace(color.CGColor)) == kCGColorSpaceModelMonochrome) {
    const CGFloat *oldComponents = CGColorGetComponents(color.CGColor);
    CGFloat components[4] = {oldComponents[0], oldComponents[0], oldComponents[0], oldComponents[1]};
    CGColorRef colorRef = CGColorCreate( colorSpaceRGB, components );
    
    UIColor *color = [UIColor colorWithCGColor:colorRef];
    CGColorRelease(colorRef);
    return color;
    } else
    return color;
    };
    
    UIColor *selfColor = convertColorToRGBSpace(self);
    otherColor = convertColorToRGBSpace(otherColor);
    CGColorSpaceRelease(colorSpaceRGB);
    
    return [selfColor isEqual:otherColor];
    }
        
46、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花
        
    [UIApplication sharedApplication].networkActivityIndicatorVisible = YES;
    
47、检查一个rect是否包含一个point
        
    // point是否在rect内
    BOOL isContains = CGRectContainsPoint(rect, point);
    
48、在指定的宽度下，让UILabel自动设置最佳font
        
    label.adjustsFontSizeToFitWidth = YES;
               
49、将一个image保存在相册中
        
    UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:, nil);
    - (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo {

        if(!error) {

            NSLog(@"successfully saved");
        } else {

            NSLog(@"error saving to photos: %@", error);
        }
    }
    或者
    #import <Photos/Photos.h>
    [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^{
    PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromImage:image];
    changeRequest.creationDate          = [NSDate date];
    } completionHandler:^(BOOL success, NSError *error) {
    if (success) {
        NSLog(@"successfully saved");
    }
    else {
        NSLog(@"error saving to photos: %@", error);
    }
    }];
        
50、为一个view添加虚线边框
        
    CAShapeLayer *border = [CAShapeLayer layer];
    border.strokeColor = [UIColor colorWithRed:67/255.0f green:37/255.0f blue:83/255.0f alpha:1].CGColor;
    border.fillColor = nil;
    border.lineDashPattern = @[@4, @2];
    border.path = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;
    border.frame = view.bounds;
    [view.layer addSublayer:border];
        
        
51、UITextView中打开或禁用复制，剪切，选择，全选等功能
        
    // 继承UITextView重写这个方法
    - (BOOL)canPerformAction:(SEL)action withSender:(id)sender
    {
    // 返回NO为禁用，YES为开启
    // 粘贴
    if (action == @selector(paste:)) return NO;
    // 剪切
    if (action == @selector(cut:)) return NO;
    // 复制
    if (action == @selector(copy:)) return NO;
    // 选择
    if (action == @selector(select:)) return NO;
    // 选中全部
    if (action == @selector(selectAll:)) return NO;
    // 删除
    if (action == @selector(delete:)) return NO;
    // 分享
    if (action == @selector(share)) return NO;
    return [super canPerformAction:action withSender:sender];
    }
        
 52、 去掉分割线多余15像素
        
    首先在viewDidLoad方法加入以下代码：
    if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) {
        [self.tableView setSeparatorInset:UIEdgeInsetsZero];
    }
    if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) {
        [self.tableView setLayoutMargins:UIEdgeInsetsZero];
    }
    然后在重写willDisplayCell方法
    - (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell
    forRowAtIndexPath:(NSIndexPath *)indexPath{
        if ([cell respondsToSelector:@selector(setSeparatorInset:)]) {
            [cell setSeparatorInset:UIEdgeInsetsZero];
        }
        if ([cell respondsToSelector:@selector(setLayoutMargins:)]) {
            [cell setLayoutMargins:UIEdgeInsetsZero];
        }
    }
        
53、iOS 获取汉字的拼音
    
    + (NSString *)transform:(NSString *)chinese {
        //将NSString装换成NSMutableString
        NSMutableString *pinyin = [chinese mutableCopy];
        //将汉字转换为拼音(带音标)
        CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);
        NSLog(@"%@", pinyin);
        //去掉拼音的音标
        CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);
        NSLog(@"%@", pinyin);
        //返回最近结果
        return pinyin;
    }
        
54、手动更改iOS状态栏的颜色
    
    - (void)setStatusBarBackgroundColor:(UIColor *)color
    {
        UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@"statusBarWindow"] valueForKey:@"statusBar"];
        
        if ([statusBar respondsToSelector:@selector(setBackgroundColor:)])
        {
            statusBar.backgroundColor = color;
        }
    }
        
55、判断当前ViewController是push还是present的方式显示的 然后返回
    
    NSArray *viewcontrollers=self.navigationController.viewControllers;
    
    if (viewcontrollers.count > 1)
    {
        if ([viewcontrollers objectAtIndex:viewcontrollers.count - 1] == self) {
            //push方式
            [self.navigationController popViewControllerAnimated:YES];
        }
    } else {
        //present方式
        [self dismissViewControllerAnimated:YES completion:nil];
    }
    
56、获取实际使用的LaunchImage图片
    
    - (NSString *)getLaunchImageName
    {
        CGSize viewSize = self.window.bounds.size;
        // 竖屏
        NSString *viewOrientation = @"Portrait";
        NSString *launchImageName = nil;
        NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@"UILaunchImages"];
        for (NSDictionary* dict in imagesDict)
        {
            CGSize imageSize = CGSizeFromString(dict[@"UILaunchImageSize"]);
            if (CGSizeEqualToSize(imageSize, viewSize) && [viewOrientation isEqualToString:dict[@"UILaunchImageOrientation"]])
            {
                launchImageName = dict[@"UILaunchImageName"];
            }
        }
        return launchImageName;
    }
    
    
    +(NSString *)translation:(NSString *)arebic
    {
        NSString *str = arebic;
        NSArray *arabic_numerals = @[@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"0"];
        NSArray *chinese_numerals = @[@"一",@"二",@"三",@"四",@"五",@"六",@"七",@"八",@"九",@"零"];
        NSArray *digits = @[@"个",@"十",@"百",@"千",@"万",@"十",@"百",@"千",@"亿",@"十",@"百",@"千",@"兆"];
        NSDictionary *dictionary = [NSDictionary dictionaryWithObjects:chinese_numerals forKeys:arabic_numerals];
        
        NSMutableArray *sums = [NSMutableArray array];
        for (int i = 0; i < str.length; i ++) {
        
            NSString *substr = [str substringWithRange:NSMakeRange(i, 1)];
            NSString *a = [dictionary objectForKey:substr];
            NSString *b = digits[str.length -i-1];
            NSString *sum = [a stringByAppendingString:b];
            
            if ([a isEqualToString:chinese_numerals[9]])
            {
                if([b isEqualToString:digits[4]] || [b isEqualToString:digits[8]])
                {
                    sum = b;
                    if ([[sums lastObject] isEqualToString:chinese_numerals[9]]) {
                        [sums removeLastObject];
                    }
                } else {
                    sum = chinese_numerals[9];
                }
                
                if ([[sums lastObject] isEqualToString:sum])
                {
                    continue;
                }
            }
            
            [sums addObject:sum];
        }
        
        NSString *sumStr = [sums componentsJoinedByString:@""];
        NSString *chinese = [sumStr substringToIndex:sumStr.length-1];
        NSLog(@"%@",str);
        NSLog(@"%@",chinese);
        return chinese;
    }
    
        
57、查找一个视图的所有子视图
    
    - (NSMutableArray *)allSubViewsForView:(UIView *)view
    {
        NSMutableArray *array = [NSMutableArray arrayWithCapacity:0];
        for (UIView *subView in view.subviews)
        {
            [array addObject:subView];
            if (subView.subviews.count > 0)
            {
                [array addObjectsFromArray:[self allSubViewsForView:subView]];
            }
        }
        return array;
    }
        
58、计算文件大小
    
    //文件大小
    - (long long)fileSizeAtPath:(NSString *)path
    {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        
        if ([fileManager fileExistsAtPath:path])
        {
            long long size = [fileManager attributesOfItemAtPath:path error:nil].fileSize;
            return size;
        }
        
        return 0;
    }
    
    //文件夹大小
    - (long long)folderSizeAtPath:(NSString *)path
    {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        long long folderSize = 0;
        if ([fileManager fileExistsAtPath:path])
        {
            NSArray *childerFiles = [fileManager subpathsAtPath:path];
            for (NSString *fileName in childerFiles)
            {
                NSString *fileAbsolutePath = [path stringByAppendingPathComponent:fileName];
                if ([fileManager fileExistsAtPath:fileAbsolutePath])
                {
                    long long size = [fileManager attributesOfItemAtPath:fileAbsolutePath error:nil].fileSize;
                    folderSize += size;
                }
            }
        }
        
        return folderSize;
    }
    
    
59、UITextField每四位加一个空格,实现代理
    
    - (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string
    {
        // 四位加一个空格
        if ([string isEqualToString:@""])
        {
            // 删除字符
            if ((textField.text.length - 2) % 5 == 0) {
                textField.text = [textField.text substringToIndex:textField.text.length - 1];
            }
            return YES;
        } else {
            if (textField.text.length % 5 == 0) {
                textField.text = [NSString stringWithFormat:@"%@ ", textField.text];
            }
        }
        return YES;
    }
    
    
    
60、获取手机安装的应用
    
    Class c =NSClassFromString(@"LSApplicationWorkspace");
    id s = [(id)c performSelector:NSSelectorFromString(@"defaultWorkspace")];
    NSArray *array = [s performSelector:NSSelectorFromString(@"allInstalledApplications")];
    for (id item in array)
    {
        NSLog(@"%@",[item performSelector:NSSelectorFromString(@"applicationIdentifier")]);
        //NSLog(@"%@",[item performSelector:NSSelectorFromString(@"bundleIdentifier")]);
        NSLog(@"%@",[item performSelector:NSSelectorFromString(@"bundleVersion")]);
        NSLog(@"%@",[item performSelector:NSSelectorFromString(@"shortVersionString")]);
    }
    
61、navigationBar根据滑动距离的渐变色实现
    
    //第一种
    - (void)scrollViewDidScroll:(UIScrollView *)scrollView
    {
        CGFloat offsetToShow = 200.0;//滑动多少就完全显示
        CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow;
        [[self.navigationController.navigationBar subviews] objectAtIndex:0].alpha = alpha;
    }
    //第二种
    - (void)scrollViewDidScroll:(UIScrollView *)scrollView
    {
        CGFloat offsetToShow = 200.0;
        CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow;
        
        [self.navigationController.navigationBar setShadowImage:[UIImage new]];
        [self.navigationController.navigationBar setBackgroundImage:[self imageWithColor:[[UIColor orangeColor]colorWithAlphaComponent:alpha]] forBarMetrics:UIBarMetricsDefault];
    }
    
    //生成一张纯色的图片
    - (UIImage *)imageWithColor:(UIColor *)color
    {
        CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
        UIGraphicsBeginImageContext(rect.size);
        CGContextRef context = UIGraphicsGetCurrentContext();
        CGContextSetFillColorWithColor(context, [color CGColor]);
        CGContextFillRect(context, rect);
        UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        
        return theImage;
    }
    
    
    
    
62、获取硬盘总容量与可用容量:
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDictionary *attributes = [fileManager attributesOfFileSystemForPath:NSHomeDirectory() error:nil];
    1
    NSLog(@"容量%.2fG",[attributes[NSFileSystemSize] doubleValue] / (powf(1024, 3)));
    NSLog(@"可用%.2fG",[attributes[NSFileSystemFreeSize] doubleValue] / powf(1024, 3));
    
    
63、UIColor 获取 RGB 值
    
    UIColor *color = [UIColor colorWithRed:0.0 green:0.0 blue:1.0 alpha:1.0];
    const CGFloat *components = CGColorGetComponents(color.CGColor);
    NSLog(@"Red: %f", components[0]);
    NSLog(@"Green: %f", components[1]);
    NSLog(@"Blue: %f", components[2]);
    NSLog(@"Alpha: %f", components[3]);
    
    
64、你可以在任何地方加上这句话，可以用来统一收起键盘
    
    [[[UIApplication sharedApplication] keyWindow] endEditing:YES];
    
    
65、NSDictionary 转 NSString
    
    // Start
    NSDictionary *parametersDic = [NSDictionary dictionaryWithObjectsAndKeys:
    self.providerStr, KEY_LOGIN_PROVIDER,
    token, KEY_TOKEN,
    response, KEY_RESPONSE,
    nil];
    
    NSData *jsonData = parametersDic == nil ? nil : [NSJSONSerialization dataWithJSONObject:parametersDic options:0 error:nil];
    NSString *requestBody = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
    将dictionary 转化为 NSData， data 转化为 string .
        
    
66、User-Agent 判断设备
    
    UIWebView 会根据User-Agent 的值来判断需要显示哪个界面。
    如果需要设置为全局，那么直接在应用启动的时候加载。
    - (void)appendUserAgent
    {
        NSString *oldAgent = [self.WebView stringByEvaluatingJavaScriptFromString:@"navigator.userAgent"];
        NSString *newAgent = [oldAgent stringByAppendingString:@"iOS"];
        
        NSDictionary *dic = [[NSDictionary alloc] initWithObjectsAndKeys:
        newAgent, @"UserAgent", nil];
        [[NSUserDefaults standardUserDefaults] registerDefaults:dic];
    }
    
67、关于编译器：关闭警告：
    
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
    [myObj performSelector:mySelector withObject:name];
    #pragma clang diagnostic pop
    
68、忽略没用的变量
    
    #pragma unused (foo)
    明确定义错误和警告
    #error Whoa, buddy, you need to check for zero here!
    #warning Dude, don't compare floating point numbers like this!
    
69、建议加载xib,xib名称用NSStringFromClass(),避免书写错误
    
    // 推荐写法
    [self.tableView registerNib:[UINib nibWithNibName:NSStringFromClass([DXRecommendTagVCell class]) bundle:nil] forCellReuseIdentifier:ID];
    // 不推荐写法
    [self.tableView registerNib:[UINib nibWithNibName:@"DXRecommendTagVCell" bundle:nil] forCellReuseIdentifier:ID];
    
70、强行关闭app的方法
    
    // 私有API
    [[UIApplication sharedApplication] performSelector:@selector(terminateWithSuccess)];
    // C语言方法
    exit(0);
    
    
    71、设置粘贴内容
    
    [UIPasteboard generalPasteboard].string = @"string";
    // 获取粘贴内容
    NSString *string = [UIPasteboard generalPasteboard].string;
    
    
72、反过来颜色转换成十六进制的字符串，这个基本上没有什么人会用到，我基本上不用
    
    + (NSString *)changeUIColorToRGB:(UIColor *)color;
    //颜色转换为字符串
    + (NSString *) changeUIColorToRGB:(UIColor *)color {

        const CGFloat *cs=CGColorGetComponents(color.CGColor);
        NSString *r = [NSString stringWithFormat:@"%@",[self  ToHex:cs[0]*255]];
        NSString *g = [NSString stringWithFormat:@"%@",[self  ToHex:cs[1]*255]];
        NSString *b = [NSString stringWithFormat:@"%@",[self  ToHex:cs[2]*255]];
        return [NSString stringWithFormat:@"#%@%@%@",r,g,b];
    }
    
    
73延时加载:
    
    // 第一种：
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    });
    // 第二种：
    [NSThread sleepForTimeInterval:2.0f];
    // 第三种：
    [self performSelector:self withObject:@selector(operation) afterDelay:1.0];
    
74、让iOS应用直接退出
    
    - (void)exitApplication {
    AppDelegate *app = [UIApplication sharedApplication].delegate;
    UIWindow *window = app.window;
    
    [UIView animateWithDuration:1.0f animations:^{
    window.alpha = 0;
    } completion:^(BOOL finished) {
    exit(0);
    }];
    }
    
75、NSArray 快速求总和 平均值 最大值 和最小值
    
    NSArray *array = [NSArray arrayWithObjects:@"2.0", @"2.3", @"3.0", @"4.0", @"10", nil];
    CGFloat sum = [[array valueForKeyPath:@"@sum.floatValue"] floatValue];
    CGFloat avg = [[array valueForKeyPath:@"@avg.floatValue"] floatValue];
    CGFloat max =[[array valueForKeyPath:@"@max.floatValue"] floatValue];
    CGFloat min =[[array valueForKeyPath:@"@min.floatValue"] floatValue];
    NSLog(@"%f\n%f\n%f\n%f",sum,avg,max,min);
    
76、TransForm属性
    
    //平移按钮
    CGAffineTransform transForm = self.buttonView.transform;
    self.buttonView.transform = CGAffineTransformTranslate(transForm, 10, 0);
    
    //旋转按钮
    CGAffineTransform transForm = self.buttonView.transform;
    self.buttonView.transform = CGAffineTransformRotate(transForm, M_PI_4);
    
    //缩放按钮
    self.buttonView.transform = CGAffineTransformScale(transForm, 1.2, 1.2);
    
    //初始化复位
    self.buttonView.transform = CGAffineTransformIdentity;
    
    
77、NSString过滤特殊字符
    
    // 定义一个特殊字符的集合
    NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:
    @"@／：；（）¥「」＂、[]{}#%-*+=_\\|~＜＞$€^•'@#$%^&*()_+'\""];
    // 过滤字符串的特殊字符
    NSString *newString = [trimString stringByTrimmingCharactersInSet:set];
    
    
78、 点击button倒计时
    
  //第一种方法
    //点击button倒计时
    #import "ViewController.h"
    @interface ViewController ()
    @property (nonatomic, strong) UIButton * timeButton;
    @property (nonatomic, strong) NSTimer * timer;
    @property (nonatomic, strong)UIButton * btn;
    @end
    @implementation ViewController
    {
        NSInteger _time;
    }
    - (void)viewDidLoad {
        [super viewDidLoad];
        _time = 5;
        self.btn = [UIButton buttonWithType:UIButtonTypeCustom]; _btn.backgroundColor = [UIColor orangeColor];
        [_btn setTitle:@"获取验证码" forState:UIControlStateNormal]; _btn.titleLabel.font = [UIFont systemFontOfSize:15];
        [_timeButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
        [_btn addTarget:self action:@selector(btnAction:) forControlEvents:UIControlEventTouchUpInside];
        [self refreshButtonWidth];
        [self.view addSubview:self.btn];
    }
    - (void)refreshButtonWidth{
        CGFloat width = 0;
        if (_btn.enabled){
        width = 100;
        } else {
        width = 200;
        }
        _btn.center = CGPointMake(self.view.frame.size.width/2, 200);
        _btn.bounds = CGRectMake(0, 0, width, 40);
        //每次刷新，保证区域正确
        [_btn setBackgroundImage:[self imageWithColor:[UIColor orangeColor] andSize:_btn.frame.size] forState:UIControlStateNormal];
        [_btn setBackgroundImage:[self imageWithColor:[UIColor lightGrayColor] andSize:_btn.frame.size] forState:UIControlStateDisabled];
    }
    - (UIImage *)imageWithColor:(UIColor *)color andSize:(CGSize)aSize{
        CGRect rect = CGRectMake(0.0f, 0.0f, aSize.width, aSize.height); UIGraphicsBeginImageContext(rect.size);
        CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect);
        UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();
        return image;
    }
    - (void)btnAction:(UIButton *)sender{
        sender.enabled = NO;
        [self refreshButtonWidth];
        [sender setTitle:[NSString stringWithFormat:@"获取验证码(%zi)", _time] forState:UIControlStateNormal];
        _timer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(timeDown) userInfo:nil repeats:YES];
    }
    - (void)timeDown{
        _time --;
        if (_time == 0) {
        [_btn setTitle:@"重新获取" forState:UIControlStateNormal]; _btn.enabled = YES;
        [self refreshButtonWidth];
        [_timer invalidate];
        _timer = nil;
        _time = 5 ;
        return;
        }
        [_btn setTitle:[NSString stringWithFormat:@"获取验证码(%zi)", _time] forState:UIControlStateNormal];
    }
    
    //第二种方法
    #pragma mark -点击发送验证码
    - (void)sendMessage:(UIButton *)btn{
        if (self.phoneField.text.length == 0) {
        [self remindMessage:@"请输入正确的手机号"];
    }else{
        __block int timeout=60;
        //倒计时时间
        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue); dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0);
        //每秒执行
        dispatch_source_set_event_handler(_timer, ^{
            if(timeout<=0){
                //倒计时结束，关闭
                dispatch_source_cancel(_timer); dispatch_async(dispatch_get_main_queue(), ^{
                // 设置界面的按钮显示 根据自己需求设置
                [btn setTitle:@"发送验证码" forState:UIControlStateNormal]; btn.userInteractionEnabled = YES;
                });
            } else {
            int seconds = timeout % 60;
            NSString *strTime = [NSString stringWithFormat:@"%d", seconds];
            if ([strTime isEqualToString:@"0"]) {
                strTime = [NSString stringWithFormat:@"%d",60];
            }
            dispatch_async(dispatch_get_main_queue(), ^{
                    //设置界面的按钮显示 根据自己需求设置
                    //NSLog(@"____%@",strTime);
                    [UIView beginAnimations:nil context:nil];
                    [UIView setAnimationDuration:1];
                    [btn setTitle:[NSString stringWithFormat:@"%@秒后重新发送",strTime] forState:UIControlStateNormal];
                    [UIView commitAnimations];
                    btn.userInteractionEnabled = NO;
                });
                timeout--;
            }
        });
        dispatch_resume(_timer);
    }
    
79、获取某个view所在的控制器
    
    - (UIViewController *)viewController{
    
        UIViewController *viewController = nil;
        UIResponder *next = self.nextResponder;
        while (next) {
        
            if ([next isKindOfClass:[UIViewController class]])
            {
                viewController = (UIViewController *)next;
                break;
            }
            next = next.nextResponder;
        }
        return viewController;
    }
    
    
80、两种方法删除NSUserDefaults所有记录
    
    //方法一
    NSString *appDomain = [[NSBundlemainBundle] bundleIdentifier];
    [[NSUserDefaultsstandardUserDefaults] removePersistentDomainForName:appDomain];
    
    
    //方法二
    - (void)resetDefaults
    {
        NSUserDefaults * defs = [NSUserDefaultsstandardUserDefaults];
        NSDictionary * dict = [defsdictionaryRepresentation];
        for (idkeyin dict) {
            [defsremoveObjectForKey:key];
        }
        [defssynchronize];
    }
    
    
81、模态推出透明界面
    
    UIViewController *vc = [[UIViewControlleralloc] init];
    UINavigationController *na = [[UINavigationControlleralloc] initWithRootViewController:vc];
    
    if ([[[UIDevicecurrentDevice] systemVersion] floatValue] >= 8.0){
        na.modalPresentationStyle = UIModalPresentationOverCurrentContext;
    } else {
        self.modalPresentationStyle=UIModalPresentationCurrentContext;
    }
    
    [self presentViewController:naanimated:YEScompletion:nil];
    
    
    
82、图片上绘制文字 写一个UIImage的category
    
    - (UIImage *)imageWithTitle:(NSString *)title fontSize:(CGFloat)fontSize {
        //画布大小
        CGSizesize=CGSizeMake(self.size.width,self.size.height);
        //创建一个基于位图的上下文
        UIGraphicsBeginImageContextWithOptions(size,NO,0.0);//opaque:NO  scale:0.0
        
        [self drawAtPoint:CGPointMake(0.0,0.0)];
        
        //文字居中显示在画布上
        NSMutableParagraphStyle* paragraphStyle = [[NSParagraphStyledefaultParagraphStyle] mutableCopy];
        paragraphStyle.lineBreakMode = NSLineBreakByCharWrapping;
        paragraphStyle.alignment=NSTextAlignmentCenter;//文字居中
        
        //计算文字所占的size,文字居中显示在画布上
        CGSizesizeText=[titleboundingRectWithSize:self.sizeoptions:NSStringDrawingUsesLineFragmentOrigin
        attributes:@{NSFontAttributeName:[UIFontsystemFontOfSize:fontSize]}context:nil].size;
        CGFloatwidth = self.size.width;
        CGFloatheight = self.size.height;
        
        CGRectrect = CGRectMake((width-sizeText.width)/2, (height-sizeText.height)/2, sizeText.width, sizeText.height);
        //绘制文字
        [titledrawInRect:rectwithAttributes:@{ NSFontAttributeName:[UIFontsystemFontOfSize:fontSize],NSForegroundColorAttributeName:[ UIColorwhiteColor],NSParagraphStyleAttributeName:paragraphStyle}];
        
        //返回绘制的新图形
        UIImage *newImage= UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        return newImage;
    }
    
    
83、
        
    
84、dispatch_group的使用
    
    dispatch_group_tdispatchGroup = dispatch_group_create();
    dispatch_group_enter(dispatchGroup);
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@"第一个请求完成");
        dispatch_group_leave(dispatchGroup);
    });
    
    dispatch_group_enter(dispatchGroup);
    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@"第二个请求完成");
        dispatch_group_leave(dispatchGroup);
    });
    
    dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^(){
        NSLog(@"请求完成");
    });
    
    
    
85、屏蔽触发事件，2秒后取消屏蔽
    
    [[UIApplication sharedApplication] beginIgnoringInteractionEvents];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    [[UIApplication sharedApplication] endIgnoringInteractionEvents]
    });
    
    
86、模糊图片
    
    //加模糊效果，image是图片，blur是模糊度
    + (UIImage *)blurryImage:(UIImage *)image withBlurLevel:(CGFloat)blur {
        //模糊度,
        if ((blur < 0.1f) || (blur > 2.0f)) {
            blur = 0.5f;
        }
        
        //boxSize必须大于0
        int boxSize = (int)(blur * 100);
        boxSize -= (boxSize % 2) + 1;
        //    iCocosLog(@"boxSize:%i",boxSize);
        //图像处理
        CGImageRef img = image.CGImage;
        
        //图像缓存,输入缓存，输出缓存
        vImage_Buffer inBuffer, outBuffer;
        vImage_Error error;
        //像素缓存
        void *pixelBuffer;
        
        //数据源提供者，Defines an opaque type that supplies Quartz with data.
        CGDataProviderRef inProvider = CGImageGetDataProvider(img);
        // provider’s data.
        CFDataRef inBitmapData = CGDataProviderCopyData(inProvider);
        
        //宽，高，字节/行，data
        inBuffer.width = CGImageGetWidth(img);
        inBuffer.height = CGImageGetHeight(img);
        inBuffer.rowBytes = CGImageGetBytesPerRow(img);
        inBuffer.data = (void*)CFDataGetBytePtr(inBitmapData);
        
        //像数缓存，字节行*图片高
        pixelBuffer = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img));
        
        outBuffer.data = pixelBuffer;
        outBuffer.width = CGImageGetWidth(img);
        outBuffer.height = CGImageGetHeight(img);
        outBuffer.rowBytes = CGImageGetBytesPerRow(img);
        
        
        // 第三个中间的缓存区,抗锯齿的效果
        void *pixelBuffer2 = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img));
        vImage_Buffer outBuffer2;
        outBuffer2.data = pixelBuffer2;
        outBuffer2.width = CGImageGetWidth(img);
        outBuffer2.height = CGImageGetHeight(img);
        outBuffer2.rowBytes = CGImageGetBytesPerRow(img);
        
        
        //Convolves a region of interest within an ARGB8888 source image by an implicit M x N kernel that has the effect of a box filter.
        error = vImageBoxConvolve_ARGB8888(&inBuffer, &outBuffer2, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);
        error = vImageBoxConvolve_ARGB8888(&outBuffer2, &inBuffer, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);
        error = vImageBoxConvolve_ARGB8888(&inBuffer, &outBuffer, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);
        
        if (error) {
            iCocosLog(@"error from convolution %ld", error);
        }
        
        //    iCocosLog(@"字节组成部分：%zu",CGImageGetBitsPerComponent(img));
        //颜色空间DeviceRGB
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        //用图片创建上下文,CGImageGetBitsPerComponent(img),7,8
        CGContextRef ctx = CGBitmapContextCreate(
        outBuffer.data,
        outBuffer.width,
        outBuffer.height,
        8,
        outBuffer.rowBytes,
        colorSpace,
        CGImageGetBitmapInfo(image.CGImage));
        
        //根据上下文，处理过的图片，重新组件
        CGImageRef imageRef = CGBitmapContextCreateImage (ctx);
        UIImage *returnImage = [UIImage imageWithCGImage:imageRef];
        
        //clean up
        CGContextRelease(ctx);
        CGColorSpaceRelease(colorSpace);
        
        free(pixelBuffer);
        free(pixelBuffer2);
        CFRelease(inBitmapData);
        
        CGColorSpaceRelease(colorSpace);
        CGImageRelease(imageRef);
        
        return returnImage;
    }
    
87、本文输入错误提示
    
    - (void)shake {
    CAKeyframeAnimation *keyFrame = [CAKeyframeAnimation animationWithKeyPath:@"position.x"];
    keyFrame.duration = 0.3;
    CGFloat x = self.layer.position.x;
    keyFrame.values = @[@(x - 30), @(x - 30), @(x + 20), @(x - 20), @(x + 10), @(x - 10), @(x + 5), @(x - 5)];
    [self.layer addAnimation:keyFrame forKey:@"shake"];
    
    }
    - (void)shake {
        CAKeyframeAnimation *animationKey = [CAKeyframeAnimationanimationWithKeyPath:@"position"];
        [animationKey setDuration:0.5f];
        
        NSArray *array = [[NSArrayalloc] initWithObjects:
        [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)],
        [NSValuevalueWithCGPoint:CGPointMake(self.center.x-5, self.center.y)],
        [NSValuevalueWithCGPoint:CGPointMake(self.center.x+5, self.center.y)],
        [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)],
        [NSValuevalueWithCGPoint:CGPointMake(self.center.x-5, self.center.y)],
        [NSValuevalueWithCGPoint:CGPointMake(self.center.x+5, self.center.y)],
        [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)],
        [NSValuevalueWithCGPoint:CGPointMake(self.center.x-5, self.center.y)],
        [NSValuevalueWithCGPoint:CGPointMake(self.center.x+5, self.center.y)],
        [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)],
        nil];
        [animationKey setValues:array];
        [array release];
        
        NSArray *times = [[NSArrayalloc] initWithObjects:
        [NSNumbernumberWithFloat:0.1f],
        [NSNumbernumberWithFloat:0.2f],
        [NSNumbernumberWithFloat:0.3f],
        [NSNumbernumberWithFloat:0.4f],
        [NSNumbernumberWithFloat:0.5f],
        [NSNumbernumberWithFloat:0.6f],
        [NSNumbernumberWithFloat:0.7f],
        [NSNumbernumberWithFloat:0.8f],
        [NSNumbernumberWithFloat:0.9f],
        [NSNumbernumberWithFloat:1.0f],
        nil];
        [animationKey setKeyTimes:times];
        [times release];
        
        [self.layeraddAnimation:animationKey forKey:@"TextFieldShake"];
    }
    
88、tabBar红点
    
    - (void)showBadgeOnItemIndex:(int)index{
    
        //移除之前的小红点
        [self removeBadgeOnItemIndex:index];
        
        //新建小红点
        UIView *badgeView = [[UIView alloc]init];
        badgeView.tag = 888 + index;
        badgeView.backgroundColor = [UIColor redColor];
        CGRect tabFrame = self.frame;
        
        //确定小红点的位置
        float percentX = (index +0.6) / TabbarItemNums;
        CGFloat x = ceilf(percentX * tabFrame.size.width);
        CGFloat y = ceilf(0.1 * tabFrame.size.height);
        badgeView.frame = CGRectMake(x, y, 8, 8);
        badgeView.layer.cornerRadius = badgeView.frame.size.width/2;
        
        [self addSubview:badgeView];
    
    }
    
    - (void)hideBadgeOnItemIndex:(int)index{
    
        //移除小红点
        [self removeBadgeOnItemIndex:index];
    
    }
    
    - (void)removeBadgeOnItemIndex:(int)index{
    
        //按照tag值进行移除
        for (UIView *subView in self.subviews) {
            if (subView.tag == 888+index) {
                [subView removeFromSuperview];
            }
        }
    }
    
    
89、//16位MD5加密方式
    
    - (NSString *)getMd5_16Bit_String:(NSString *)srcString{
        //提取32位MD5散列的中间16位
        NSString *md5_32Bit_String=[self getMd5_32Bit_String:srcString];
        NSString *result = [[md5_32Bit_String substringToIndex:24] substringFromIndex:8];//即9～25位
        
        return result;
    }
    
    
    //32位MD5加密方式
    - (NSString *)getMd5_32Bit_String:(NSString *)srcString{
        const char *cStr = [srcString UTF8String];
        unsigned char digest[CC_MD5_DIGEST_LENGTH];
        CC_MD5( cStr, strlen(cStr), digest );
        NSMutableString *result = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2];
        for(int i = 0; i < CC_MD5_DIGEST_LENGTH; i++)
            [result appendFormat:@"%02x", digest[i]];
        
        return result;
    }
    
    
90、MOV转Mp4
    
    - (void)movFileTransformToMP4WithSourceUrl:(NSURL *)sourceUrl completion:(void(^)(NSString *Mp4FilePath))comepleteBlock
    {
        /**
        *  mov格式转mp4格式
        */
        AVURLAsset *avAsset = [AVURLAsset URLAssetWithURL:sourceUrl options:nil];
        
        NSArray *compatiblePresets = [AVAssetExportSession exportPresetsCompatibleWithAsset:avAsset];
        
        NSLog(@"%@",compatiblePresets);
        
        if ([compatiblePresets containsObject:AVAssetExportPresetHighestQuality]) {
        
            AVAssetExportSession *exportSession = [[AVAssetExportSession alloc] initWithAsset:avAsset presetName:AVAssetExportPresetMediumQuality];
            
            
            NSDate *date = [NSDate date];
            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
            [formatter setDateFormat:@"yyyyMMddHHmmss"];
            NSString *uniqueName = [NSString stringWithFormat:@"%@.mp4",[formatter stringFromDate:date]];
            NSString * resultPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:uniqueName];//PATH_OF_DOCUMENT为documents路径
            
            NSLog(@"output File Path : %@",resultPath);
            
            exportSession.outputURL = [NSURL fileURLWithPath:resultPath];
            
            exportSession.outputFileType = AVFileTypeMPEG4;//可以配置多种输出文件格式
            
            exportSession.shouldOptimizeForNetworkUse = YES;
            
            [exportSession exportAsynchronouslyWithCompletionHandler:^(void) {
            
                switch (exportSession.status) {
                
                    case AVAssetExportSessionStatusUnknown:
                    
                    break;
                    
                    case AVAssetExportSessionStatusWaiting:
                    
                    break;
                    
                    case AVAssetExportSessionStatusExporting:
                    
                    break;
                    
                    case AVAssetExportSessionStatusCompleted:
                    {
                        comepleteBlock(resultPath);
                        
                        NSLog(@"mp4 file size:%lf MB",[NSData dataWithContentsOfURL:exportSession.outputURL].length/1024.f/1024.f);
                    }
                    break;
                    
                    case AVAssetExportSessionStatusFailed:
                    
                    break;
                    
                    case AVAssetExportSessionStatusCancelled:
                    
                    break;
                    
                }
                
            }];
        }
    }
    
91、获取当前最顶层的ViewController
    
    - (UIViewController *)topViewController {
        UIViewController *resultVC;
        resultVC = [self _topViewController:[[UIApplication sharedApplication].keyWindow rootViewController]];
        while (resultVC.presentedViewController) {
        resultVC = [self _topViewController:resultVC.presentedViewController];
        }
        return resultVC;
    }
    
    - (UIViewController *)_topViewController:(UIViewController *)vc {
        if ([vc isKindOfClass:[UINavigationController class]]) {
                return [self _topViewController:[(UINavigationController *)vc topViewController]];
            } else if ([vc isKindOfClass:[UITabBarController class]]) {
                return [self _topViewController:[(UITabBarController *)vc selectedViewController]];
            } else {
                return vc;
        }
        return nil;
    }
    使用方法
    UIViewController *topmostVC = [self topViewController];
    
    
92、设置TextField左右视图
    
    -(id)initWithFrame:(CGRect)frame drawingLeft:(UIImageView *)icon drawingRight:(UIButton *)bu{
        self = [super initWithFrame:frame];
        if (self) {
        self.leftView = icon;
            self.leftViewMode = UITextFieldViewModeAlways;
            self.rightView= bu;
            self.rightViewMode=UITextFieldViewModeAlways;
        }
        return self;
    }
    -(CGRect)leftViewRectForBounds:(CGRect)bounds{
        CGRect iconRect = [super leftViewRectForBounds:bounds];
        iconRect.origin.x += 5;// 右偏10
        return iconRect;
    }
    -(CGRect)rightViewRectForBounds:(CGRect)bounds
    {
        CGRect burect=[super rightViewRectForBounds:bounds];
        burect.origin.x +=-10;
        return burect;
    }
    
    
93、获取版本号提示版本更新
    
    -(void)VersionButton
    {
        NSString * string=[NSString stringWithContentsOfURL:[NSURL URLWithString:@"http://itunes.apple.com/lookup?id=??????????"] encoding:NSUTF8StringEncoding error:nil];
        if (string!=nil && [string length]>0 && [string rangeOfString:@"version"].length==7) {
            [self checkenAppUpdate:string];
        }
    }
    -(void)checkenAppUpdate:(NSString *)appinfo
    {
        NSString * version=[[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleVersion"];
        NSString * appInfo1=[appinfo substringFromIndex:[appinfo rangeOfString:@"\"version\":"].location+10];
        appInfo1=[[appInfo1 substringToIndex:[appInfo1 rangeOfString:@","].location] stringByReplacingOccurrencesOfString:@"\"" withString:@""];
        if (![appInfo1 isEqualToString:version]) {
            UIAlertView * alert=[[UIAlertView alloc]initWithTitle:@"" message:[NSString stringWithFormat:@"新版本%@, 已经发布",appInfo1] delegate:self cancelButtonTitle:@"知道了" otherButtonTitles: nil];
            alert.delegate=self;
            [alert addButtonWithTitle:@"前往更新"];
            [alert show];
            alert.tag=20;
        }
    }
    -(void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex
    {
        if (buttonIndex==1 & alertView.tag==20) {
            NSString * url=@"https://appsto.re/cn/-naScb.i";
            [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]];
        }
    }
    
    
    
94、解决时差问题
    
    //解决时差问题
    NSDate * date = sender.date;
    NSTimeZone *zone = [NSTimeZone systemTimeZone];
    NSInteger interval = [zone secondsFromGMTForDate: date];
    NSDate *localeDate = [date  dateByAddingTimeInterval: interval];
    
    //时差转化
    NSDate *datenow = [NSDate date];//输出结果:2014-12-12 02:23:25 +0000晚八个小时
    NSTimeZone *zone = [NSTimeZone systemTimeZone];
    NSInteger interval = [zone secondsFromGMTForDate:datenow];
    NSDate *localeDate = [datenow  dateByAddingTimeInterval: interval];//2014-12-12 10:23:25 +0000
    NSLog(@"%@", localeDate);
    
    //将秒数转化为日期格式
    NSDate *confromTimesp = [NSDatedateWithTimeIntervalSince1970:1363948516];
    NSLog(@"1363948516  = %@",confromTimesp);//2013-03-22 10:35:16 +0000
    
    //将秒数转化为特定格式的日期格式
    NSString *str=@"1368082020";//时间戳
    NSTimeInterval time=[str doubleValue]+28800;//因为时差问题要加8小时 == 28800 sec
    NSDate *detaildate=[NSDate dateWithTimeIntervalSince1970:time];
    NSLog(@"date:%@",[detaildate description]);
    //实例化一个NSDateFormatter对象
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //设定时间格式,这里可以设置成自己需要的格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd"];
    NSString *currentDateStr = [dateFormatter stringFromDate: detaildate];
    
    //最终版本
    NSString * startStr = [NSStringstringWithFormat:@"%@",dic[@"startdate"]];
    NSTimeInterval startTime = [startStr doubleValue] / 1000 + 28800;
    NSDate * startLocalDate = [NSDatedateWithTimeIntervalSince1970:startTime];
    NSDateFormatter * startFormatter = [[NSDateFormatter alloc]init];
    [startFormatter setDateFormat:@"yyyy.MM.dd"];
    NSString * startDate = [startFormatter stringFromDate:startLocalDate];
    
    
    
95.使用系统tabbar时，tabbar上方会有一条线，如果想去掉这条线，添加如下代码即可：

    [self.tabBar setClipsToBounds:YES];


96.iOS实现多级界面模态之后的返回

	UIViewController *rootVC = self.presentingViewController;
	while (rootVC.presentingViewController) {
	    rootVC = rootVC.presentingViewController;
	}       
	[rootVC dismissViewControllerAnimated:YES completion:nil];

97.解决多次present之后返回到指定的界面

	UIViewController *vc =self.presentingViewController;
	//BondDeviceController要跳转的界面
	while (![vc isKindOfClass:[BondDeviceController class]]) {
	    
	    vc = vc.presentingViewController;
	}
	[vc dismissViewControllerAnimated:YES completion:nil];


98.如何修改UITabbarItem上面图片的位置和文字的位置

	PersonalViewController *VC3 = [[PersonalViewController alloc]init];
	VC3.tabBarItem.title = @"个人";
	VC3.tabBarItem.image = [UIImage imageNamed:@"个人灰色"];
	VC3.tabBarItem.selectedImage = [[UIImage imageNamed:@"个人亮色"] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
	//设置文字的位置
	[VC3.tabBarItem setTitlePositionAdjustment:UIOffsetMake(0, -5)];
	//设置图片的位置
	VC3.tabBarItem.imageInsets = UIEdgeInsetsMake(5, 0, -5, 0);



















-------------------------------------------
        
# 优秀的GitHub库   
* [YBPopupMenu](https://github.com/lyb5834/YBPopupMenu)
* [仿微信](https://github.com/LinXunFeng/LXFWeChat.git)

        
        
        
        
        
        
        
        
        
